# -*- coding: utf-8 -*-
"""MatAplicada02.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hAAefO5Rdu07K6pNFrqjEXhnfZtF3G0j
"""

import scipy.linalg as linalg
import numpy as np

def substituicao_avancada(A, b):
    # Pegamos a quantidade de elementos no vetor b
    n = len(b)
    # Criamos um vetor solução x de comprimento n que inicialmente receberá apenas valores nulos
    x = [0] * n
    # O primeiro valor da solução recebe o primeiro valor de b dividido por A[0][0]
    x[0] = b[0] / A[0][0]

    # Realizamos o algoritmo da substituição avançada (Pulino,)
    for i in range(1, n):
        soma = 0
        for j in range(i):
            soma += A[i][j] * x[j]
        x[i] = (b[i] - soma) / A[i][i]

    print("x =")

    return x



def substituicao_atrasada(A, b):
    # Pegamos a quantidade de elementos no vetor b
    n = len(b)
    # Criamos um vetor solução x de comprimento n que inicialmente receberá apenas valores nulos
    x = [0] * n
    # O último valor da solução recebe o último valor de b dividido por A[n-1][n-1]
    x[n-1] = b[n-1] / A[n-1][n-1]

    # Realizamos o algoritmo da substituição atrasada (Pulino,)
    for i in range(n-2, -1, -1):
        soma = 0
        for j in range(i+1, n):
            soma += A[i][j] * x[j]
        x[i] = (b[i] - soma) / A[i][i]

    print("x =")

    return x

# Definimos uma função de fatoração LU através do método scipy.linalg.lu()
# Sendo P a matriz das permutações aplicadas na matriz indentidade
# L a matriz triangular inferior
# U a matriz triangular superior
def fatoracao_lu(A):
    P, L, U = linalg.lu(A)
    return L, U, P

# Criamos uma função para decidir qual algoritmo será utilizado
def resolver_sistema_triangular(A, b):
    # Pegamos a quantidade de elementos no vetor b
    n = len(b)

    # Verificar se a matriz é triangular superior ou inferior
    is_triangular_superior = True
    is_triangular_inferior = True

    for i in range(n):
        for j in range(i+1, n):
            if A[i][j] != 0:
                is_triangular_inferior = False
            if A[j][i] != 0:
                is_triangular_superior = False



    if is_triangular_superior:
        print("Como temos uma matriz triangular superior, aplicamos a substituição atrasada.")
        return substituicao_atrasada(A, b)  # Aplica substituição atrasada

    elif is_triangular_inferior:
        print("Como temos uma matriz triangular inferior, aplicamos a substituição avançada.")
        return substituicao_avancada(A, b)  # Aplica substituição avançada

    else:
        print("A matriz não é triangular. Aplicando fatoração LU para resolver o sistema.")
        L, U, P = fatoracao_lu(A)
        n = len(b)
        x = [0] * n
        # Resolvemos o sistema L*y = b e encontramos os valores do vetor y
        y = linalg.solve(L, np.dot(P, b))
        # Usamos o vetor y encontrado para resolver o sistema U*x = y e, finalmente, encontrar a solução x.
        x = linalg.solve(U, y)

        print("L =\n", L)

        print("U =\n", U)

        print("P =\n", P)

        print("x =")

        return x

A = [[2, -1, 0],
     [1, 3, 4],
     [1, 1, 1]]

b = [1, 6, 2]

x = resolver_sistema_triangular(A, b)
print(x)

